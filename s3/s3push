#!/usr/bin/env python3
"""
s3push - Push files/directories to S3 with path-based organization.

Usage:
    s3push <local_path>                    # Auto-detect repo, use relative path
    s3push <local_path> --to <s3_path>     # Explicit S3 destination
    s3push <local_path> --sync             # Use aws s3 sync for directories

Examples:
    s3push ./outputs/model.pt              # → s3://bucket/data/{repo}/outputs/model.pt
    s3push ./data --to experiments/run1    # → s3://bucket/data/experiments/run1/data
    s3push ./logs/ --sync                  # Sync directory efficiently
"""
import argparse
import os
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Optional


BUCKET = "matan-ml-exp-bucket"
DATA_PREFIX = "data"


@dataclass
class PushResult:
    success: bool
    local_path: str
    s3_path: str
    message: str


def get_git_repo_name() -> Optional[str]:
    """Get the name of the current git repository, or None if not in a repo."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            check=True,
        )
        repo_path = Path(result.stdout.strip())
        return repo_path.name
    except subprocess.CalledProcessError:
        return None


def get_relative_path_in_repo(local_path: Path) -> Optional[str]:
    """Get path relative to git repo root, or None if not in a repo."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            check=True,
        )
        repo_root = Path(result.stdout.strip())
        abs_path = local_path.resolve()

        # Check if path is inside repo
        try:
            rel_path = abs_path.relative_to(repo_root)
            return str(rel_path)
        except ValueError:
            # Path is outside repo
            return None
    except subprocess.CalledProcessError:
        return None


def build_s3_path(local_path: Path, explicit_dest: Optional[str]) -> str:
    """Build the full S3 path for the upload."""
    if explicit_dest:
        # User specified explicit destination
        dest = explicit_dest.strip("/")
        filename = local_path.name
        return f"s3://{BUCKET}/{DATA_PREFIX}/{dest}/{filename}"

    # Try to auto-detect from git repo
    repo_name = get_git_repo_name()
    rel_path = get_relative_path_in_repo(local_path)

    if repo_name and rel_path:
        return f"s3://{BUCKET}/{DATA_PREFIX}/{repo_name}/{rel_path}"
    elif repo_name:
        # Path is outside repo but we know repo name
        return f"s3://{BUCKET}/{DATA_PREFIX}/{repo_name}/{local_path.name}"
    else:
        # Not in a repo, use just the filename under a generic path
        print(f"Warning: Not in a git repo. Use --to to specify destination.", file=sys.stderr)
        return f"s3://{BUCKET}/{DATA_PREFIX}/misc/{local_path.name}"


def push_file(local_path: Path, s3_path: str) -> PushResult:
    """Push a single file to S3."""
    cmd = ["aws", "s3", "cp", str(local_path), s3_path]
    print(f"Uploading: {local_path} → {s3_path}")

    # Stream output in real-time (don't capture)
    result = subprocess.run(cmd)

    if result.returncode == 0:
        return PushResult(True, str(local_path), s3_path, "Upload successful")
    else:
        return PushResult(False, str(local_path), s3_path, "Upload failed")


def push_directory(local_path: Path, s3_path: str, sync: bool = False) -> PushResult:
    """Push a directory to S3."""
    # Ensure s3_path ends without trailing slash for consistency
    s3_path = s3_path.rstrip("/")

    if sync:
        cmd = ["aws", "s3", "sync", str(local_path), s3_path]
        action = "Syncing"
    else:
        cmd = ["aws", "s3", "cp", "--recursive", str(local_path), s3_path]
        action = "Uploading"

    print(f"{action}: {local_path}/ → {s3_path}/")

    # Stream output in real-time (don't capture)
    result = subprocess.run(cmd)

    if result.returncode == 0:
        return PushResult(True, str(local_path), s3_path, f"{action} successful")
    else:
        return PushResult(False, str(local_path), s3_path, f"{action} failed")


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Push files/directories to S3",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument("local_path", type=Path, help="Local file or directory to push")
    parser.add_argument("--to", dest="s3_dest", help="Explicit S3 destination path (under data/)")
    parser.add_argument("--sync", action="store_true", help="Use sync instead of cp for directories")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be uploaded without uploading")

    args = parser.parse_args()

    local_path: Path = args.local_path.resolve()

    if not local_path.exists():
        print(f"Error: {local_path} does not exist", file=sys.stderr)
        return 1

    s3_path = build_s3_path(local_path, args.s3_dest)

    if args.dry_run:
        print(f"Would upload: {local_path} → {s3_path}")
        return 0

    if local_path.is_file():
        result = push_file(local_path, s3_path)
    else:
        result = push_directory(local_path, s3_path, sync=args.sync)

    if result.success:
        print(f"✓ {result.message}")
        print(f"  {result.s3_path}")
        return 0
    else:
        print(f"✗ Error: {result.message}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
